(1).
假设以行优先顺序存储三维数组A[5][6][7],其中元素A[0][0][0]的地址为1100，
且每个元素占2个存储单元，则A[4][3][2]的地址是()


首先弄清楚 A[4][3][2] 所对应的元素个数一共有多少个，
A[0] - A[3] 元素个数为 = 4*6*7*2
A[4][0]-A[4][2] 的元素个数为 = 3*7*2
A[4][3][0] - A[4][3][2] 的元素个数为 = 3*2
一共(4*6*7+3*7+3)*2 = 382

382+1100 = 1482


(2).
#define NUMA 10000000
#define NUMB 1000
int a[NUMA], b[NUMB];

void pa()
{
    int i, j;
    for(i = 0; i < NUMB; ++i)
        for(j = 0; j < NUMA; ++j)
            ++a[j];
}
void pb()
{
    int i, j;
    for(i = 0; i < NUMA; ++i)
        for(j = 0; j < NUMB; ++j)
            ++b[j];
}
测试时pb比pa快，数组a比数组b大很多，可能跨更多的页，缺页率高或者缓存命中更低，所以pb快
小循环放外面，大循环放里面是没错的。 但是这道题目是例外，相当于一个大数组赋值少数次和小数组赋值多次！
这样肯定小数组的比较快。如果把题目中的++a[]，和++b[]换成一个同一个数，那么结果刚好相反。亲测，是这样！

(3).
三元组做到下面三条便可实现矩阵的转置：
（1）将矩阵的行列值交换。
（2）将每个三元组中的 i 和 j 相互调换。
（3）重排三元组之间的次序。

(4).
每个元素要用行号,列号,元素值来表示,在用三元组表示稀疏矩阵,
还要三个成员来记住,矩阵的行数列数,总的元素数,所以所需的字节数是
